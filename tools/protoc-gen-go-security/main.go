package main

import (
	"flag"
	"fmt"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	securityv1 "github.com/origadmin/runtime/gen/go/security/v1"
)

const version = "1.0.0"

var showVersion = flag.Bool("version", false, "print the version and exit")

func main() {
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-go-security %s\n", version)
		return
	}

	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}

	servicePolicyMap := make(map[string]string)
	gatewayPolicyMap := make(map[string]string)

	for _, service := range file.Services {
		for _, method := range service.Methods {
			policyName := getPolicyName(method)
			if policyName == "" {
				continue
			}

			serviceFullName := fmt.Sprintf("/%s/%s", service.Desc.FullName(), method.Desc.Name())
			servicePolicyMap[serviceFullName] = policyName

			httpRule := getHttpRule(method)
			if httpRule != nil {
				var httpMethod, httpPath string
				switch t := httpRule.Pattern.(type) {
				case *annotations.HttpRule_Get:
					httpMethod, httpPath = "GET", t.Get
				case *annotations.HttpRule_Post:
					httpMethod, httpPath = "POST", t.Post
				case *annotations.HttpRule_Put:
					httpMethod, httpPath = "PUT", t.Put
				case *annotations.HttpRule_Delete:
					httpMethod, httpPath = "DELETE", t.Delete
				case *annotations.HttpRule_Patch:
					httpMethod, httpPath = "PATCH", t.Patch
				}
				if httpMethod != "" && httpPath != "" {
					key := fmt.Sprintf("%s:%s", httpMethod, httpPath)
					gatewayPolicyMap[key] = policyName
				}
			}
		}
	}

	if len(servicePolicyMap) == 0 && len(gatewayPolicyMap) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + ".pb.security.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-go-security. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	g.P("import security \"github.com/origadmin/runtime/security\"")
	g.P()

	g.P("func init() {")
	g.P("	serviceMap := map[string]string{")
	for k, v := range servicePolicyMap {
		g.P(`		"`, k, `": "`, v, `",`)
	}
	g.P("	}")
	g.P()
	g.P("	gatewayMap := map[string]string{")
	for k, v := range gatewayPolicyMap {
		g.P(`		"`, k, `": "`, v, `",`)
	}
	g.P("	}")
	g.P()
	g.P("	security.RegisterPolicies(serviceMap, gatewayMap)")
	g.P("}")
}

func getPolicyName(method *protogen.Method) string {
	opts, ok := method.Desc.Options().(*descriptorpb.MethodOptions)
	if !ok {
		return ""
	}
	ext := proto.GetExtension(opts, securityv1.E_Security)
	rule, ok := ext.(*securityv1.SecurityRule)
	if !ok || rule == nil {
		return ""
	}
	return rule.Policy
}

func getHttpRule(method *protogen.Method) *annotations.HttpRule {
	opts, ok := method.Desc.Options().(*descriptorpb.MethodOptions)
	if !ok {
		return nil
	}
	ext := proto.GetExtension(opts, annotations.E_Http)
	rule, ok := ext.(*annotations.HttpRule)
	if !ok || rule == nil {
		return nil
	}
	return rule
}
