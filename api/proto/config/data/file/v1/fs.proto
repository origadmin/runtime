syntax = "proto3";

package runtime.api.config.data.file.v1;

import "gnostic/openapi/v3/annotations.proto";
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";

option go_package = "github.com/origadmin/runtime/api/gen/go/config/data/file/v1;filev1";

// FileInfo describes a file or directory.
message FileInfo {
  string name = 1 [(gnostic.openapi.v3.property) = {description: "The name of the file or directory."}];
  string path = 2 [(gnostic.openapi.v3.property) = {description: "The full path of the file or directory."}];
  bool is_dir = 3 [(gnostic.openapi.v3.property) = {description: "Whether the entry is a directory."}];
  int64 size = 4 [(gnostic.openapi.v3.property) = {description: "The size of the file in bytes."}];
  google.protobuf.Timestamp mod_time = 5 [(gnostic.openapi.v3.property) = {description: "The last modification time."}];
}

// FileService defines the operations for file and directory manipulation.
service FileService {
  // --- Basic Operations ---

  // List files and directories at a given path.
  rpc List(ListRequest) returns (ListResponse) {
    option (google.api.http) = {get: "/v1/file/list"};
  }

  // Get information about a single file or directory.
  rpc Stat(StatRequest) returns (StatResponse) {
    option (google.api.http) = {get: "/v1/file/stat"};
  }

  // Create a new directory.
  rpc Mkdir(MkdirRequest) returns (MkdirResponse) {
    option (google.api.http) = {
      post: "/v1/file/mkdir"
      body: "*"
    };
  }

  // Delete a file or directory.
  rpc Delete(DeleteRequest) returns (DeleteResponse) {
    option (google.api.http) = {
      post: "/v1/file/delete"
      body: "*"
    };
  }

  // Rename or move a file or directory.
  rpc Rename(RenameRequest) returns (RenameResponse) {
    option (google.api.http) = {
      post: "/v1/file/rename"
      body: "*"
    };
  }

  // --- Streaming Operations ---

  // Read a file's content as a stream.
  rpc Read(ReadRequest) returns (stream ReadResponse) {
    option (google.api.http) = {get: "/v1/file/read"};
  }

  // Write a file's content via a stream.
  // NOTE: This is suitable for reliable networks. For client-side uploads,
  // use the chunked upload methods.
  rpc Write(stream WriteRequest) returns (WriteResponse) {}

  // --- Chunked Upload Operations ---

  // Initiates a new chunked upload and returns an upload_id.
  rpc InitiateUpload(InitiateUploadRequest) returns (InitiateUploadResponse) {
    option (google.api.http) = {
      post: "/v1/file/uploads:initiate"
      body: "*"
    };
  }

  // Uploads a chunk of data for a given upload_id.
  // NOTE: gRPC-Gateway does not support client-streaming RPCs well for file uploads.
  // This RPC should be called directly via gRPC or a custom HTTP handler.
  rpc UploadChunk(stream UploadChunkRequest) returns (UploadChunkResponse) {}

  // Finalizes a chunked upload, assembling the chunks into the final file.
  rpc FinalizeUpload(FinalizeUploadRequest) returns (FinalizeUploadResponse) {
    option (google.api.http) = {
      post: "/v1/file/uploads:finalize"
      body: "*"
    };
  }
}

// --- Message Definitions for Basic Operations ---

message ListRequest {
  string path = 1 [(gnostic.openapi.v3.property) = {description: "The path of the directory to list."}];
}

message ListResponse {
  repeated FileInfo files = 1 [(gnostic.openapi.v3.property) = {description: "A list of files and directories."}];
}

message StatRequest {
  string path = 1 [(gnostic.openapi.v3.property) = {description: "The path of the file or directory to get information about."}];
}

message StatResponse {
  FileInfo file = 1 [(gnostic.openapi.v3.property) = {description: "Information about the file or directory."}];
}

message MkdirRequest {
  string path = 1 [(gnostic.openapi.v3.property) = {description: "The path of the directory to create."}];
}

message MkdirResponse {}

message DeleteRequest {
  string path = 1 [(gnostic.openapi.v3.property) = {description: "The path of the file or directory to delete."}];
  // Optional: If true and path is a directory, delete it recursively.
  bool recursive = 2 [(gnostic.openapi.v3.property) = {description: "Whether to delete recursively if the path is a directory."}];
}

message DeleteResponse {}

message RenameRequest {
  string from_path = 1 [(gnostic.openapi.v3.property) = {description: "The original path of the file or directory."}];
  string to_path = 2 [(gnostic.openapi.v3.property) = {description: "The new path for the file or directory."}];
}

message RenameResponse {}

// --- Message Definitions for Streaming Operations ---

message ReadRequest {
  string path = 1 [(gnostic.openapi.v3.property) = {description: "The path of the file to read."}];
}

message ReadResponse {
  bytes chunk = 1 [(gnostic.openapi.v3.property) = {description: "A chunk of the file's content."}];
}

message WriteRequest {
  oneof data {
    // The first message must contain the metadata.
    WriteRequestMetadata metadata = 1;
    // Subsequent messages contain the file's binary chunks.
    bytes chunk = 2;
  }
}

message WriteRequestMetadata {
  string path = 1 [(gnostic.openapi.v3.property) = {description: "The path of the file to write to."}];
}

message WriteResponse {
  int64 size = 1 [(gnostic.openapi.v3.property) = {description: "The total size of the written file."}];
  string path = 2 [(gnostic.openapi.v3.property) = {description: "The path of the written file."}];
}

// --- Message Definitions for Chunked Upload ---

message InitiateUploadRequest {
  string path = 1 [(gnostic.openapi.v3.property) = {description: "The final path for the file being uploaded."}];
}

message InitiateUploadResponse {
  string upload_id = 1 [(gnostic.openapi.v3.property) = {description: "A unique ID for the chunked upload session."}];
}

message UploadChunkRequest {
  oneof data {
    // The first message of a new chunk stream can contain metadata.
    UploadChunkMetadata metadata = 1;
    // Subsequent messages contain the file's binary chunks.
    bytes chunk = 2;
  }
}

message UploadChunkMetadata {
  string upload_id = 1 [(gnostic.openapi.v3.property) = {description: "The ID of the chunked upload session."}];
  // The position in the file to write this chunk.
  int64 offset = 2 [(gnostic.openapi.v3.property) = {description: "The byte offset in the file to write this chunk."}];
}

message UploadChunkResponse {
  string upload_id = 1 [(gnostic.openapi.v3.property) = {description: "The ID of the chunked upload session."}];
  // The number of bytes successfully written.
  int64 written_size = 2 [(gnostic.openapi.v3.property) = {description: "The number of bytes successfully written in this chunk."}];
}

message FinalizeUploadRequest {
  string upload_id = 1 [(gnostic.openapi.v3.property) = {description: "The ID of the chunked upload session to finalize."}];
  // Optional: The SHA256 checksum of the entire file for validation.
  string content_sha256 = 2 [(gnostic.openapi.v3.property) = {description: "Optional SHA256 checksum of the entire file for validation."}];
}

message FinalizeUploadResponse {
  FileInfo file = 1 [(gnostic.openapi.v3.property) = {description: "Information about the finalized file."}];
}
