// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package securityv1

import (
	fmt "fmt"
	errors "github.com/go-kratos/kratos/v2/errors"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

// The default, unspecified reason. This is required by proto3 syntax.
func IsSecurityErrorReasonUnspecified(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_SECURITY_ERROR_REASON_UNSPECIFIED.String() && e.Code == 500
}

// The default, unspecified reason. This is required by proto3 syntax.
func ErrorSecurityErrorReasonUnspecified(format string, args ...interface{}) *errors.Error {
	return errors.New(500, SecurityErrorReason_SECURITY_ERROR_REASON_UNSPECIFIED.String(), fmt.Sprintf(format, args...))
}

// The provided credentials (e.g., username/password) are invalid.
func IsInvalidCredentials(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_INVALID_CREDENTIALS.String() && e.Code == 401
}

// The provided credentials (e.g., username/password) are invalid.
func ErrorInvalidCredentials(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_INVALID_CREDENTIALS.String(), fmt.Sprintf(format, args...))
}

// The authentication token has expired.
func IsTokenExpired(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_TOKEN_EXPIRED.String() && e.Code == 401
}

// The authentication token has expired.
func ErrorTokenExpired(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_TOKEN_EXPIRED.String(), fmt.Sprintf(format, args...))
}

// The authentication token is malformed or invalid.
func IsTokenInvalid(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_TOKEN_INVALID.String() && e.Code == 401
}

// The authentication token is malformed or invalid.
func ErrorTokenInvalid(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_TOKEN_INVALID.String(), fmt.Sprintf(format, args...))
}

// The authentication token is missing from the request.
func IsTokenMissing(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_TOKEN_MISSING.String() && e.Code == 401
}

// The authentication token is missing from the request.
func ErrorTokenMissing(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_TOKEN_MISSING.String(), fmt.Sprintf(format, args...))
}

// The claims within the token are invalid.
func IsInvalidClaims(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_INVALID_CLAIMS.String() && e.Code == 401
}

// The claims within the token are invalid.
func ErrorInvalidClaims(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_INVALID_CLAIMS.String(), fmt.Sprintf(format, args...))
}

// The bearer token is specifically invalid or malformed.
func IsInvalidBearerToken(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_INVALID_BEARER_TOKEN.String() && e.Code == 401
}

// The bearer token is specifically invalid or malformed.
func ErrorInvalidBearerToken(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_INVALID_BEARER_TOKEN.String(), fmt.Sprintf(format, args...))
}

// The signing method used in the token is not supported.
func IsUnsupportedSigningMethod(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_UNSUPPORTED_SIGNING_METHOD.String() && e.Code == 401
}

// The signing method used in the token is not supported.
func ErrorUnsupportedSigningMethod(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_UNSUPPORTED_SIGNING_METHOD.String(), fmt.Sprintf(format, args...))
}

// Failed to sign a new token.
func IsSignTokenFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_SIGN_TOKEN_FAILED.String() && e.Code == 500
}

// Failed to sign a new token.
func ErrorSignTokenFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(500, SecurityErrorReason_SIGN_TOKEN_FAILED.String(), fmt.Sprintf(format, args...))
}

// The user is authenticated but does not have permission for the specific resource or action.
func IsInvalidAuthorization(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_INVALID_AUTHORIZATION.String() && e.Code == 403
}

// The user is authenticated but does not have permission for the specific resource or action.
func ErrorInvalidAuthorization(format string, args ...interface{}) *errors.Error {
	return errors.New(403, SecurityErrorReason_INVALID_AUTHORIZATION.String(), fmt.Sprintf(format, args...))
}
