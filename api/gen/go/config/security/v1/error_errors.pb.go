// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package securityv1

import (
	fmt "fmt"
	errors "github.com/go-kratos/kratos/v2/errors"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

// The default, unspecified reason. This is required by proto3 syntax.
func IsSecurityErrorReasonUnspecified(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_SECURITY_ERROR_REASON_UNSPECIFIED.String() && e.Code == 500
}

// The default, unspecified reason. This is required by proto3 syntax.
func ErrorSecurityErrorReasonUnspecified(format string, args ...interface{}) *errors.Error {
	return errors.New(500, SecurityErrorReason_SECURITY_ERROR_REASON_UNSPECIFIED.String(), fmt.Sprintf(format, args...))
}

// The provided credentials (e.g., username/password) are invalid.
func IsCredentialsInvalid(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_CREDENTIALS_INVALID.String() && e.Code == 401
}

// The provided credentials (e.g., username/password) are invalid.
func ErrorCredentialsInvalid(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_CREDENTIALS_INVALID.String(), fmt.Sprintf(format, args...))
}

// The authentication token has expired.
func IsTokenExpired(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_TOKEN_EXPIRED.String() && e.Code == 401
}

// The authentication token has expired.
func ErrorTokenExpired(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_TOKEN_EXPIRED.String(), fmt.Sprintf(format, args...))
}

// The authentication token is malformed or invalid.
func IsTokenInvalid(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_TOKEN_INVALID.String() && e.Code == 401
}

// The authentication token is malformed or invalid.
func ErrorTokenInvalid(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_TOKEN_INVALID.String(), fmt.Sprintf(format, args...))
}

// The authentication token is missing from the request.
func IsTokenMissing(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_TOKEN_MISSING.String() && e.Code == 401
}

// The authentication token is missing from the request.
func ErrorTokenMissing(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_TOKEN_MISSING.String(), fmt.Sprintf(format, args...))
}

// The claims within the token are invalid.
func IsClaimsInvalid(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_CLAIMS_INVALID.String() && e.Code == 401
}

// The claims within the token are invalid.
func ErrorClaimsInvalid(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_CLAIMS_INVALID.String(), fmt.Sprintf(format, args...))
}

// The bearer token is specifically invalid or malformed.
func IsBearerTokenInvalid(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_BEARER_TOKEN_INVALID.String() && e.Code == 401
}

// The bearer token is specifically invalid or malformed.
func ErrorBearerTokenInvalid(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_BEARER_TOKEN_INVALID.String(), fmt.Sprintf(format, args...))
}

// The signing method used in the token is not supported.
func IsSigningMethodUnsupported(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_SIGNING_METHOD_UNSUPPORTED.String() && e.Code == 401
}

// The signing method used in the token is not supported.
func ErrorSigningMethodUnsupported(format string, args ...interface{}) *errors.Error {
	return errors.New(401, SecurityErrorReason_SIGNING_METHOD_UNSUPPORTED.String(), fmt.Sprintf(format, args...))
}

// Failed to sign a new token.
func IsTokenSignFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_TOKEN_SIGN_FAILED.String() && e.Code == 500
}

// Failed to sign a new token.
func ErrorTokenSignFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(500, SecurityErrorReason_TOKEN_SIGN_FAILED.String(), fmt.Sprintf(format, args...))
}

// The user is authenticated but does not have permission for the specific resource or action.
func IsPermissionDenied(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == SecurityErrorReason_PERMISSION_DENIED.String() && e.Code == 403
}

// The user is authenticated but does not have permission for the specific resource or action.
func ErrorPermissionDenied(format string, args ...interface{}) *errors.Error {
	return errors.New(403, SecurityErrorReason_PERMISSION_DENIED.String(), fmt.Sprintf(format, args...))
}
