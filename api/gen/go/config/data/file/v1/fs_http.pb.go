// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.0
// - protoc             (unknown)
// source: config/data/file/v1/fs.proto

package filev1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationFileServiceDelete = "/config.data.file.v1.FileService/Delete"
const OperationFileServiceFinalizeUpload = "/config.data.file.v1.FileService/FinalizeUpload"
const OperationFileServiceInitiateUpload = "/config.data.file.v1.FileService/InitiateUpload"
const OperationFileServiceList = "/config.data.file.v1.FileService/List"
const OperationFileServiceMkdir = "/config.data.file.v1.FileService/Mkdir"
const OperationFileServiceRename = "/config.data.file.v1.FileService/Rename"
const OperationFileServiceStat = "/config.data.file.v1.FileService/Stat"

type FileServiceHTTPServer interface {
	// Delete Delete a file or directory.
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// FinalizeUpload Finalizes a chunked upload, assembling the chunks into the final file.
	FinalizeUpload(context.Context, *FinalizeUploadRequest) (*FinalizeUploadResponse, error)
	// InitiateUpload Initiates a new chunked upload and returns an upload_id.
	InitiateUpload(context.Context, *InitiateUploadRequest) (*InitiateUploadResponse, error)
	// List List files and directories at a given path.
	List(context.Context, *ListRequest) (*ListResponse, error)
	// Mkdir Create a new directory.
	Mkdir(context.Context, *MkdirRequest) (*MkdirResponse, error)
	// Rename Rename or move a file or directory.
	Rename(context.Context, *RenameRequest) (*RenameResponse, error)
	// Stat Get information about a single file or directory.
	Stat(context.Context, *StatRequest) (*StatResponse, error)
}

func RegisterFileServiceHTTPServer(s *http.Server, srv FileServiceHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/file/list", _FileService_List0_HTTP_Handler(srv))
	r.GET("/v1/file/stat", _FileService_Stat0_HTTP_Handler(srv))
	r.POST("/v1/file/mkdir", _FileService_Mkdir0_HTTP_Handler(srv))
	r.POST("/v1/file/delete", _FileService_Delete0_HTTP_Handler(srv))
	r.POST("/v1/file/rename", _FileService_Rename0_HTTP_Handler(srv))
	r.POST("/v1/file/uploads:initiate", _FileService_InitiateUpload0_HTTP_Handler(srv))
	r.POST("/v1/file/uploads:finalize", _FileService_FinalizeUpload0_HTTP_Handler(srv))
}

func _FileService_List0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceList)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.List(ctx, req.(*ListRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_Stat0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in StatRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceStat)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Stat(ctx, req.(*StatRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*StatResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_Mkdir0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MkdirRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceMkdir)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Mkdir(ctx, req.(*MkdirRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MkdirResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_Delete0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceDelete)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Delete(ctx, req.(*DeleteRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_Rename0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RenameRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceRename)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Rename(ctx, req.(*RenameRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RenameResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_InitiateUpload0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in InitiateUploadRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceInitiateUpload)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.InitiateUpload(ctx, req.(*InitiateUploadRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*InitiateUploadResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_FinalizeUpload0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in FinalizeUploadRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceFinalizeUpload)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.FinalizeUpload(ctx, req.(*FinalizeUploadRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FinalizeUploadResponse)
		return ctx.Result(200, reply)
	}
}

type FileServiceHTTPClient interface {
	// Delete Delete a file or directory.
	Delete(ctx context.Context, req *DeleteRequest, opts ...http.CallOption) (rsp *DeleteResponse, err error)
	// FinalizeUpload Finalizes a chunked upload, assembling the chunks into the final file.
	FinalizeUpload(ctx context.Context, req *FinalizeUploadRequest, opts ...http.CallOption) (rsp *FinalizeUploadResponse, err error)
	// InitiateUpload Initiates a new chunked upload and returns an upload_id.
	InitiateUpload(ctx context.Context, req *InitiateUploadRequest, opts ...http.CallOption) (rsp *InitiateUploadResponse, err error)
	// List List files and directories at a given path.
	List(ctx context.Context, req *ListRequest, opts ...http.CallOption) (rsp *ListResponse, err error)
	// Mkdir Create a new directory.
	Mkdir(ctx context.Context, req *MkdirRequest, opts ...http.CallOption) (rsp *MkdirResponse, err error)
	// Rename Rename or move a file or directory.
	Rename(ctx context.Context, req *RenameRequest, opts ...http.CallOption) (rsp *RenameResponse, err error)
	// Stat Get information about a single file or directory.
	Stat(ctx context.Context, req *StatRequest, opts ...http.CallOption) (rsp *StatResponse, err error)
}

type FileServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewFileServiceHTTPClient(client *http.Client) FileServiceHTTPClient {
	return &FileServiceHTTPClientImpl{client}
}

// Delete Delete a file or directory.
func (c *FileServiceHTTPClientImpl) Delete(ctx context.Context, in *DeleteRequest, opts ...http.CallOption) (*DeleteResponse, error) {
	var out DeleteResponse
	pattern := "/v1/file/delete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceDelete))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// FinalizeUpload Finalizes a chunked upload, assembling the chunks into the final file.
func (c *FileServiceHTTPClientImpl) FinalizeUpload(ctx context.Context, in *FinalizeUploadRequest, opts ...http.CallOption) (*FinalizeUploadResponse, error) {
	var out FinalizeUploadResponse
	pattern := "/v1/file/uploads:finalize"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceFinalizeUpload))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// InitiateUpload Initiates a new chunked upload and returns an upload_id.
func (c *FileServiceHTTPClientImpl) InitiateUpload(ctx context.Context, in *InitiateUploadRequest, opts ...http.CallOption) (*InitiateUploadResponse, error) {
	var out InitiateUploadResponse
	pattern := "/v1/file/uploads:initiate"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceInitiateUpload))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// List List files and directories at a given path.
func (c *FileServiceHTTPClientImpl) List(ctx context.Context, in *ListRequest, opts ...http.CallOption) (*ListResponse, error) {
	var out ListResponse
	pattern := "/v1/file/list"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFileServiceList))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// Mkdir Create a new directory.
func (c *FileServiceHTTPClientImpl) Mkdir(ctx context.Context, in *MkdirRequest, opts ...http.CallOption) (*MkdirResponse, error) {
	var out MkdirResponse
	pattern := "/v1/file/mkdir"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceMkdir))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// Rename Rename or move a file or directory.
func (c *FileServiceHTTPClientImpl) Rename(ctx context.Context, in *RenameRequest, opts ...http.CallOption) (*RenameResponse, error) {
	var out RenameResponse
	pattern := "/v1/file/rename"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceRename))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// Stat Get information about a single file or directory.
func (c *FileServiceHTTPClientImpl) Stat(ctx context.Context, in *StatRequest, opts ...http.CallOption) (*StatResponse, error) {
	var out StatResponse
	pattern := "/v1/file/stat"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFileServiceStat))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
