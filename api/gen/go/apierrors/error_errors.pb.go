// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package apierrors

import (
	fmt "fmt"
	errors "github.com/go-kratos/kratos/v2/errors"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

// An unknown error occurred.
// Maps to HTTP 500.
func IsUnknownError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_UNKNOWN_ERROR.String() && e.Code == 500
}

// An unknown error occurred.
// Maps to HTTP 500.
func ErrorUnknownError(format string, args ...interface{}) *errors.Error {
	return errors.New(500, ErrorReason_UNKNOWN_ERROR.String(), fmt.Sprintf(format, args...))
}

// The request was invalid or malformed.
// Maps to HTTP 400.
func IsValidationError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_VALIDATION_ERROR.String() && e.Code == 400
}

// The request was invalid or malformed.
// Maps to HTTP 400.
func ErrorValidationError(format string, args ...interface{}) *errors.Error {
	return errors.New(400, ErrorReason_VALIDATION_ERROR.String(), fmt.Sprintf(format, args...))
}

// The requested resource was not found.
// Maps to HTTP 404.
func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_NOT_FOUND.String() && e.Code == 404
}

// The requested resource was not found.
// Maps to HTTP 404.
func ErrorNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, ErrorReason_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// The server encountered an internal error.
// Maps to HTTP 500.
func IsInternalServerError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_INTERNAL_SERVER_ERROR.String() && e.Code == 500
}

// The server encountered an internal error.
// Maps to HTTP 500.
func ErrorInternalServerError(format string, args ...interface{}) *errors.Error {
	return errors.New(500, ErrorReason_INTERNAL_SERVER_ERROR.String(), fmt.Sprintf(format, args...))
}

// The HTTP method is not supported for the requested resource.
// Maps to HTTP 405.
func IsMethodNotAllowed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_METHOD_NOT_ALLOWED.String() && e.Code == 405
}

// The HTTP method is not supported for the requested resource.
// Maps to HTTP 405.
func ErrorMethodNotAllowed(format string, args ...interface{}) *errors.Error {
	return errors.New(405, ErrorReason_METHOD_NOT_ALLOWED.String(), fmt.Sprintf(format, args...))
}

// The server timed out waiting for the request.
// Maps to HTTP 408.
func IsRequestTimeout(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_REQUEST_TIMEOUT.String() && e.Code == 408
}

// The server timed out waiting for the request.
// Maps to HTTP 408.
func ErrorRequestTimeout(format string, args ...interface{}) *errors.Error {
	return errors.New(408, ErrorReason_REQUEST_TIMEOUT.String(), fmt.Sprintf(format, args...))
}

// The request could not be completed due to a conflict with the current state of the resource.
// Maps to HTTP 409.
func IsConflict(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_CONFLICT.String() && e.Code == 409
}

// The request could not be completed due to a conflict with the current state of the resource.
// Maps to HTTP 409.
func ErrorConflict(format string, args ...interface{}) *errors.Error {
	return errors.New(409, ErrorReason_CONFLICT.String(), fmt.Sprintf(format, args...))
}

// The user has sent too many requests in a given amount of time.
// Maps to HTTP 429.
func IsTooManyRequests(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_TOO_MANY_REQUESTS.String() && e.Code == 429
}

// The user has sent too many requests in a given amount of time.
// Maps to HTTP 429.
func ErrorTooManyRequests(format string, args ...interface{}) *errors.Error {
	return errors.New(429, ErrorReason_TOO_MANY_REQUESTS.String(), fmt.Sprintf(format, args...))
}

// The server is not ready to handle the request.
// Maps to HTTP 503.
func IsServiceUnavailable(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_SERVICE_UNAVAILABLE.String() && e.Code == 503
}

// The server is not ready to handle the request.
// Maps to HTTP 503.
func ErrorServiceUnavailable(format string, args ...interface{}) *errors.Error {
	return errors.New(503, ErrorReason_SERVICE_UNAVAILABLE.String(), fmt.Sprintf(format, args...))
}

// The server, while acting as a gateway or proxy, did not receive a timely response from the upstream server.
// Maps to HTTP 504.
func IsGatewayTimeout(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_GATEWAY_TIMEOUT.String() && e.Code == 504
}

// The server, while acting as a gateway or proxy, did not receive a timely response from the upstream server.
// Maps to HTTP 504.
func ErrorGatewayTimeout(format string, args ...interface{}) *errors.Error {
	return errors.New(504, ErrorReason_GATEWAY_TIMEOUT.String(), fmt.Sprintf(format, args...))
}

// The user is not authenticated.
// Maps to HTTP 401.
func IsUnauthenticated(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_UNAUTHENTICATED.String() && e.Code == 401
}

// The user is not authenticated.
// Maps to HTTP 401.
func ErrorUnauthenticated(format string, args ...interface{}) *errors.Error {
	return errors.New(401, ErrorReason_UNAUTHENTICATED.String(), fmt.Sprintf(format, args...))
}

// The user is authenticated but does not have permission to perform the action.
// Maps to HTTP 403.
func IsForbidden(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_FORBIDDEN.String() && e.Code == 403
}

// The user is authenticated but does not have permission to perform the action.
// Maps to HTTP 403.
func ErrorForbidden(format string, args ...interface{}) *errors.Error {
	return errors.New(403, ErrorReason_FORBIDDEN.String(), fmt.Sprintf(format, args...))
}
